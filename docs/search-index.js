crystal_doc_search_index_callback({"repository_name":"lattice","body":"# lattice-core\n\nTODO: Write a description here\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     lattice-core:\n       github: your-github-user/lattice-core\n   ```\n\n2. Run `shards install`\n\n## Usage\n\n```crystal\nrequire \"lattice-core\"\n```\n\nTODO: Write usage instructions here\n\n## Development\n\nTODO: Write development instructions here\n\n## Contributing\n\n1. Fork it (<https://github.com/your-github-user/lattice-core/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [your-name-here](https://github.com/your-github-user) - creator and maintainer\n","program":{"html_id":"lattice/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"lattice","program":true,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"lattice/Lattice","path":"Lattice.html","kind":"module","full_name":"Lattice","name":"Lattice","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"lattice","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"lattice/Lattice/AbstractNArray","path":"Lattice/AbstractNArray.html","kind":"class","full_name":"Lattice::AbstractNArray(T)","name":"AbstractNArray","abstract":true,"superclass":{"html_id":"lattice/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"lattice/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"lattice/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"lattice","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[{"html_id":"lattice/Lattice/NArray","kind":"class","full_name":"Lattice::NArray(T)","name":"NArray"}],"including_types":[],"namespace":{"html_id":"lattice/Lattice","kind":"module","full_name":"Lattice","name":"Lattice"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[{"id":"[](index):AbstractNArray(T)-instance-method","html_id":"[](index):AbstractNArray(T)-instance-method","name":"[]","doc":"Takes a single index into the NArray, returning a slice of the largest dimension possible.\nFor example, if `a` is a matrix, `a[0]` will be a vector.","summary":"<p>Takes a single index into the NArray, returning a slice of the largest dimension possible.</p>","abstract":true,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index) : AbstractNArray(T)","source_link":null,"def":{"name":"[]","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"AbstractNArray(T)","visibility":"Public","body":""}},{"id":"[](*coord):AbstractNArray(T)-instance-method","html_id":"[](*coord):AbstractNArray(T)-instance-method","name":"[]","doc":"Higher-order slicing operations (like slicing in numpy)","summary":"<p>Higher-order slicing operations (like slicing in numpy)</p>","abstract":true,"args":[{"name":"coord","doc":null,"default_value":"","external_name":"coord","restriction":""}],"args_string":"(*coord) : AbstractNArray(T)","source_link":null,"def":{"name":"[]","args":[{"name":"coord","doc":null,"default_value":"","external_name":"coord","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"AbstractNArray(T)","visibility":"Public","body":""}},{"id":"clone:AbstractNArray(T)-instance-method","html_id":"clone:AbstractNArray(T)-instance-method","name":"clone","doc":"Returns a deep copy of the array.","summary":"<p>Returns a deep copy of the array.</p>","abstract":true,"args":[],"args_string":" : AbstractNArray(T)","source_link":null,"def":{"name":"clone","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"AbstractNArray(T)","visibility":"Public","body":""}},{"id":"dup:AbstractNArray(T)-instance-method","html_id":"dup:AbstractNArray(T)-instance-method","name":"dup","doc":"Returns a shallow copy of the array.","summary":"<p>Returns a shallow copy of the array.</p>","abstract":true,"args":[],"args_string":" : AbstractNArray(T)","source_link":null,"def":{"name":"dup","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"AbstractNArray(T)","visibility":"Public","body":""}},{"id":"get(*coord):T-instance-method","html_id":"get(*coord):T-instance-method","name":"get","doc":"Given a fully-qualified coordinate, returns the scalar at that position.","summary":"<p>Given a fully-qualified coordinate, returns the scalar at that position.</p>","abstract":true,"args":[{"name":"coord","doc":null,"default_value":"","external_name":"coord","restriction":""}],"args_string":"(*coord) : T","source_link":null,"def":{"name":"get","args":[{"name":"coord","doc":null,"default_value":"","external_name":"coord","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"T","visibility":"Public","body":""}},{"id":"shape:Array(Int32)-instance-method","html_id":"shape:Array(Int32)-instance-method","name":"shape","doc":"Returns an array where `shape[i]` is the size of the NArray in the `i`th dimension.","summary":"<p>Returns an array where <code>shape[i]</code> is the size of the NArray in the <code>i</code>th dimension.</p>","abstract":true,"args":[],"args_string":" : Array(Int32)","source_link":null,"def":{"name":"shape","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Array(Int32)","visibility":"Public","body":""}},{"id":"to_scalar:T-instance-method","html_id":"to_scalar:T-instance-method","name":"to_scalar","doc":"Maps a zero-dimensional NArray to the element it contains.","summary":"<p>Maps a zero-dimensional NArray to the element it contains.</p>","abstract":true,"args":[],"args_string":" : T","source_link":null,"def":{"name":"to_scalar","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"T","visibility":"Public","body":""}}],"macros":[],"types":[]},{"html_id":"lattice/Lattice/DimensionError","path":"Lattice/DimensionError.html","kind":"class","full_name":"Lattice::DimensionError","name":"DimensionError","abstract":false,"superclass":{"html_id":"lattice/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"lattice/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"lattice/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"lattice/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"lattice","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"lattice/Lattice","kind":"module","full_name":"Lattice","name":"Lattice"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"lattice/Lattice/NArray","path":"Lattice/NArray.html","kind":"class","full_name":"Lattice::NArray(T)","name":"NArray","abstract":false,"superclass":{"html_id":"lattice/Lattice/AbstractNArray","kind":"class","full_name":"Lattice::AbstractNArray","name":"AbstractNArray"},"ancestors":[{"html_id":"lattice/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"lattice/Lattice/AbstractNArray","kind":"class","full_name":"Lattice::AbstractNArray","name":"AbstractNArray"},{"html_id":"lattice/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"lattice/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"lattice","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"lattice/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"lattice/Lattice","kind":"module","full_name":"Lattice","name":"Lattice"},"doc":"An `NArray` is a multidimensional array for any arbitrary type.\nIt is the most general implementation of AbstractNArray, and as a result\nonly implements primitive data operations (construction, data reading,\ndata writing, and region sampling / slicing).\n\n`NArray` is designed to provide the best user experience possible, and\nthat methodology led to the use of the `method_missing` macro for element-wise\noperations. Please read its documentation, as it provides a large amount\nof functionality that may otherwise appear missing.","summary":"<p>An <code><a href=\"../Lattice/NArray.html\">NArray</a></code> is a multidimensional array for any arbitrary type.</p>","class_methods":[{"id":"build(shape,&block:Array(Int32),Int32->T):NArray(T)-class-method","html_id":"build(shape,&block:Array(Int32),Int32->T):NArray(T)-class-method","name":"build","doc":"Constructs an `NArray` using a user-provided *shape* (see `shape`) and a callback.\nThe provided callback should map a multidimensional index (and an optional packed\nindex) to the value you wish to store at that position.\nFor example, to create the 2x2 identity matrix:\n```\nLattice::NArray.build([2, 2]) do |indices|\n  if indices[0] == indices[1]\n    1\n  else\n    0\n  end\nend\n```\nWhich will create:\n```text\n[[1, 0, 0],\n  0, 1, 0],\n  0, 0, 1]]\n```\nThe buffer index allows you to easily index elements in lexicographic order.\nFor example:\n```\nNArray.build([5, 1]) { |indices, index| index }\n```\nWill create:\n```text\n[[0],\n [1],\n [2],\n [3],\n [4]]\n```","summary":"<p>Constructs an <code><a href=\"../Lattice/NArray.html\">NArray</a></code> using a user-provided <em>shape</em> (see <code><a href=\"../Lattice/NArray.html#shape:Array(Int32)-instance-method\">#shape</a></code>) and a callback.</p>","abstract":false,"args":[{"name":"shape","doc":null,"default_value":"","external_name":"shape","restriction":""}],"args_string":"(shape, &block : Array(Int32), Int32 -> T) : NArray(T)","source_link":null,"def":{"name":"build","args":[{"name":"shape","doc":null,"default_value":"","external_name":"shape","restriction":""}],"double_splat":null,"splat_index":null,"yields":2,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(Array(Int32), Int32 -> T)"},"return_type":"NArray(T)","visibility":"Public","body":"NArray(T).new(shape) do |packed_index|\n  yield unpack_index(packed_index, shape), packed_index\nend"}},{"id":"common_container(*objects)-class-method","html_id":"common_container(*objects)-class-method","name":"common_container","doc":"Given a list of `NArray`s, returns the smallest shape array in which any one of those `NArrays` can be contained.\nTODO: Example","summary":"<p>Given a list of <code><a href=\"../Lattice/NArray.html\">NArray</a></code>s, returns the smallest shape array in which any one of those <code>NArrays</code> can be contained.</p>","abstract":false,"args":[{"name":"objects","doc":null,"default_value":"","external_name":"objects","restriction":""}],"args_string":"(*objects)","source_link":null,"def":{"name":"common_container","args":[{"name":"objects","doc":null,"default_value":"","external_name":"objects","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"shapes = objects.to_a.map do |x|\n  x.shape\nend\nmax_dimension = (shapes.map(&.size)).max\ncontainer = (0...max_dimension).map do |dim_idx|\n  sizes_in_dim = shapes.map do |shape|\n    shape[dim_idx]?\n  end\n  sizes_in_dim.compact.max\nend\ncontainer\n"}},{"id":"fill(shape,value:T)-class-method","html_id":"fill(shape,value:T)-class-method","name":"fill","doc":"Fill an array of given size with a given value. Note that if value is an `Object`, only its reference will be copied\n- all elements would refer to a single object.","summary":"<p>Fill an array of given size with a given value.</p>","abstract":false,"args":[{"name":"shape","doc":null,"default_value":"","external_name":"shape","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"T"}],"args_string":"(shape, value : T)","source_link":null,"def":{"name":"fill","args":[{"name":"shape","doc":null,"default_value":"","external_name":"shape","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"T"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"NArray(T).new(shape) do\n  value\nend"}},{"id":"pack_index(indices,shape):Int32-class-method","html_id":"pack_index(indices,shape):Int32-class-method","name":"pack_index","doc":null,"summary":null,"abstract":false,"args":[{"name":"indices","doc":null,"default_value":"","external_name":"indices","restriction":""},{"name":"shape","doc":null,"default_value":"","external_name":"shape","restriction":""}],"args_string":"(indices, shape) : Int32","source_link":null,"def":{"name":"pack_index","args":[{"name":"indices","doc":null,"default_value":"","external_name":"indices","restriction":""},{"name":"shape","doc":null,"default_value":"","external_name":"shape","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Int32","visibility":"Public","body":"if !(valid_index?(indices, shape))\n  raise(IndexError.new(\"Cannot pack index: the given index is out of bounds for this NArray along at least one dimension.\"))\nend\nmemo = 0\nindices.each_with_index do |array_index, dim|\n  step = (shape[(dim + 1)..]? || [1]).product\n  memo = memo + (step * indices[dim])\nend\nmemo\n"}},{"id":"unpack_index(index,shape):Array(Int32)-class-method","html_id":"unpack_index(index,shape):Array(Int32)-class-method","name":"unpack_index","doc":null,"summary":null,"abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""},{"name":"shape","doc":null,"default_value":"","external_name":"shape","restriction":""}],"args_string":"(index, shape) : Array(Int32)","source_link":null,"def":{"name":"unpack_index","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""},{"name":"shape","doc":null,"default_value":"","external_name":"shape","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Array(Int32)","visibility":"Public","body":"indices = Array(Int32).new(shape.size, 0)\nshape.reverse.each_with_index do |length, dim|\n  indices[dim] = index % length\n  index = index // length\nend\nindices.reverse\n"}},{"id":"valid_index?(indices,shape)-class-method","html_id":"valid_index?(indices,shape)-class-method","name":"valid_index?","doc":null,"summary":null,"abstract":false,"args":[{"name":"indices","doc":null,"default_value":"","external_name":"indices","restriction":""},{"name":"shape","doc":null,"default_value":"","external_name":"shape","restriction":""}],"args_string":"(indices, shape)","source_link":null,"def":{"name":"valid_index?","args":[{"name":"indices","doc":null,"default_value":"","external_name":"indices","restriction":""},{"name":"shape","doc":null,"default_value":"","external_name":"shape","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if indices.size > shape.size\n  return false\nend\nindices.each_with_index do |length, dim|\n  if shape[dim] <= length\n    return false\n  end\nend\ntrue\n"}},{"id":"wrap(*objects:NArray(T),pad=false):NArray(T)-class-method","html_id":"wrap(*objects:NArray(T),pad=false):NArray(T)-class-method","name":"wrap","doc":"Adds a dimension at highest level, where each \"row\" is an input NArray.\nIf pad is false, then throw error if shapes of objects do not match;\notherwise, pad subarrays along each axis to match whichever is largest in that axis","summary":"<p>Adds a dimension at highest level, where each \"row\" is an input NArray.</p>","abstract":false,"args":[{"name":"objects","doc":null,"default_value":"","external_name":"objects","restriction":"NArray(T)"},{"name":"pad","doc":null,"default_value":"false","external_name":"pad","restriction":""}],"args_string":"(*objects : NArray(T), pad = <span class=\"n\">false</span>) : NArray(T)","source_link":null,"def":{"name":"wrap","args":[{"name":"objects","doc":null,"default_value":"","external_name":"objects","restriction":"NArray(T)"},{"name":"pad","doc":null,"default_value":"false","external_name":"pad","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"NArray(T)","visibility":"Public","body":"shapes = objects.to_a.map do |x|\n  x.shape\nend\nif pad\n  container = common_container(*objects)\n  raise(NotImplementedError.new(\"As of this time, NArray.wrap() cannot pad arrays for you. Come back after reshaping has been implemented, or get off the couch and go do it yourself.\"))\nelse\n  container = shapes[0]\n  if shapes.any? do |shape|\n    shape != container\n  end\n    raise(DimensionError.new(\"Cannot wrap these arrays: shapes do not match. Pass argument pad:true if you want to reshape arrays as necessary.\"))\n  end\nend\ncontainer.insert(0, objects.size)\ncombined_buffer = objects.reduce([] of T) do |memo, i|\n  memo.concat(i.buffer.to_a)\nend\nNArray(T).new(container) do |i|\n  combined_buffer[i]\nend\n"}},{"id":"wrap(*objects)-class-method","html_id":"wrap(*objects)-class-method","name":"wrap","doc":"creates an NArray-type vector from a tuple of scalars.","summary":"<p>creates an NArray-type vector from a tuple of scalars.</p>","abstract":false,"args":[{"name":"objects","doc":null,"default_value":"","external_name":"objects","restriction":""}],"args_string":"(*objects)","source_link":null,"def":{"name":"wrap","args":[{"name":"objects","doc":null,"default_value":"","external_name":"objects","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"NArray.new(objects.to_a)"}}],"constructors":[{"id":"new(shape,&)-class-method","html_id":"new(shape,&)-class-method","name":"new","doc":"Creates an `NArray` using only a shape (see `shape`) and a packed index.\nThis is used internally to make code faster - converting from a packed\nindex to an unpacked index isn't needed for many constructors, and generating\nthem would waste resources.\nFor more information, see `pack_index`, `buffer`, and `build`","summary":"<p>Creates an <code><a href=\"../Lattice/NArray.html\">NArray</a></code> using only a shape (see <code><a href=\"../Lattice/NArray.html#shape:Array(Int32)-instance-method\">#shape</a></code>) and a packed index.</p>","abstract":false,"args":[{"name":"shape","doc":null,"default_value":"","external_name":"shape","restriction":""}],"args_string":"(shape, &)","source_link":null,"def":{"name":"new","args":[{"name":"shape","doc":null,"default_value":"","external_name":"shape","restriction":""}],"double_splat":null,"splat_index":null,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = NArray(T).allocate\n_.initialize(shape) do |_arg0|\n  yield _arg0\nend\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}},{"id":"new(nested_array)-class-method","html_id":"new(nested_array)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"nested_array","doc":null,"default_value":"","external_name":"nested_array","restriction":""}],"args_string":"(nested_array)","source_link":null,"def":{"name":"new","args":[{"name":"nested_array","doc":null,"default_value":"","external_name":"nested_array","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"shape = recursive_probe_array(nested_array)\nexpected_element_count = shape.product\nelements = container_for_base_types(nested_array, expected_element_count)\nrecursive_extract_to_array(nested_array, shape, elements)\nbuffer = Slice.new(elements.to_unsafe, expected_element_count)\ninstance = NArray(typeof(elements[0])).allocate\ninstance.initialize(shape, buffer)\ninstance\n"}}],"instance_methods":[{"id":"[](*coord):NArray(T)-instance-method","html_id":"[](*coord):NArray(T)-instance-method","name":"[]","doc":"Higher-order slicing operations (like slicing in numpy)","summary":"<p>Higher-order slicing operations (like slicing in numpy)</p>","abstract":false,"args":[{"name":"coord","doc":null,"default_value":"","external_name":"coord","restriction":""}],"args_string":"(*coord) : NArray(T)","source_link":null,"def":{"name":"[]","args":[{"name":"coord","doc":null,"default_value":"","external_name":"coord","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"NArray(T)","visibility":"Public","body":"shape, mapping = extract_buffer_indices(coord)\nNArray(T).new(shape) do |i|\n  @buffer[mapping[i]]\nend\n"}},{"id":"[](index):NArray(T)-instance-method","html_id":"[](index):NArray(T)-instance-method","name":"[]","doc":"Takes a single index into the NArray, returning a slice of the largest dimension possible.\nFor example, if `a` is a matrix, `a[0]` will be a vector. There is a special case when\nindexing into a 1D `NArray` - the scalar at the index provided will be wrapped in an\n`NArray`. This is to preserve type-safety - if you want to extract the scalar as type `T`,\ninvoke `#to_scalar`.","summary":"<p>Takes a single index into the NArray, returning a slice of the largest dimension possible.</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index) : NArray(T)","source_link":null,"def":{"name":"[]","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"NArray(T)","visibility":"Public","body":"if dimensions == 1\n  new_shape = [1]\nelse\n  new_shape = @shape[1..]\nend\nstep = new_shape.product\nnew_buffer = @buffer[index * step, step]\nNArray(T).new(new_shape, new_buffer.clone)\n"}},{"id":"[]=(bool_mask:NArray(Bool),value:T)-instance-method","html_id":"[]=(bool_mask:NArray(Bool),value:T)-instance-method","name":"[]=","doc":"replaces all values in a boolean mask with a given value","summary":"<p>replaces all values in a boolean mask with a given value</p>","abstract":false,"args":[{"name":"bool_mask","doc":null,"default_value":"","external_name":"bool_mask","restriction":"NArray(Bool)"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"T"}],"args_string":"(bool_mask : NArray(Bool), value : T)","source_link":null,"def":{"name":"[]=","args":[{"name":"bool_mask","doc":null,"default_value":"","external_name":"bool_mask","restriction":"NArray(Bool)"},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"T"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if bool_mask.shape != @shape\n  raise(DimensionError.new(\"Cannot perform masking: mask shape does not match array shape.\"))\nend\nbool_mask.buffer.each_with_index do |bool_val, idx|\n  if bool_val\n    @buffer[idx] = value\n  end\nend\n"}},{"id":"[]=(*args:*U)forallU-instance-method","html_id":"[]=(*args:*U)forallU-instance-method","name":"[]=","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":"*U"}],"args_string":"(*args : <span class=\"o\">*</span><span class=\"t\">U</span>) forall U","source_link":null,"def":{"name":"[]=","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":"*U"}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"{% if true %}\n                set([{% for i in 0...(U.size - 1) %}args[{{ i }}] {% if i < (U.size - 2) %}, {% end %}{% end %}], args.last)\n            {% end %}"}},{"id":"buffer:Slice(T)-instance-method","html_id":"buffer:Slice(T)-instance-method","name":"buffer","doc":"Stores the elements of an `NArray` in lexicographic (row-major) order.","summary":"<p>Stores the elements of an <code><a href=\"../Lattice/NArray.html\">NArray</a></code> in lexicographic (row-major) order.</p>","abstract":false,"args":[],"args_string":" : Slice(T)","source_link":null,"def":{"name":"buffer","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Slice(T)","visibility":"Public","body":"@buffer"}},{"id":"canonicalize_index(index,axis)-instance-method","html_id":"canonicalize_index(index,axis)-instance-method","name":"canonicalize_index","doc":null,"summary":null,"abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""},{"name":"axis","doc":null,"default_value":"","external_name":"axis","restriction":""}],"args_string":"(index, axis)","source_link":null,"def":{"name":"canonicalize_index","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""},{"name":"axis","doc":null,"default_value":"","external_name":"axis","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if index < 0\n  return @shape[axis] + index\nelse\n  return index\nend"}},{"id":"canonicalize_range(range,axis):Tuple(Range(Int32,Int32),Int32)-instance-method","html_id":"canonicalize_range(range,axis):Tuple(Range(Int32,Int32),Int32)-instance-method","name":"canonicalize_range","doc":"Given a range in some dimension (typically the domain to slice in), returns a canonical\nform where both indexes are positive and the range is strictly inclusive of its bounds.\nThis method also returns a direction parameter, which is 1 iff `begin` < `end` and\n-1 iff `end` < `begin`","summary":"<p>Given a range in some dimension (typically the domain to slice in), returns a canonical form where both indexes are positive and the range is strictly inclusive of its bounds.</p>","abstract":false,"args":[{"name":"range","doc":null,"default_value":"","external_name":"range","restriction":""},{"name":"axis","doc":null,"default_value":"","external_name":"axis","restriction":""}],"args_string":"(range, axis) : Tuple(Range(Int32, Int32), Int32)","source_link":null,"def":{"name":"canonicalize_range","args":[{"name":"range","doc":null,"default_value":"","external_name":"range","restriction":""},{"name":"axis","doc":null,"default_value":"","external_name":"axis","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Tuple(Range(Int32, Int32), Int32)","visibility":"Public","body":"positive_begin = canonicalize_index(range.begin || 0, axis)\npositive_end = canonicalize_index(range.end || (@shape[axis] - 1), axis)\ndirection = (positive_end - positive_begin) >= 0 ? 1 : -1\nif range.excludes_end? && range.end\n  if positive_begin == positive_end\n    raise(IndexError.new(\"Could not canonicalize range: #{range} does not span any integers.\"))\n  end\n  positive_end = positive_end - direction\nend\nif [positive_begin, positive_end].any? do |idx|\n  idx < 0 || idx >= @shape[axis]\nend\n  raise(IndexError.new(\"Could not canonicalize range: #{range} is not a sensible index range in axis #{axis}.\"))\nend\n{Range.new(positive_begin, positive_end), direction}\n"}},{"id":"clone:NArray(T)-instance-method","html_id":"clone:NArray(T)-instance-method","name":"clone","doc":"Creates a deep copy of this NArray;\nAllocates a new buffer of the same shape, and calls #clone on every item in the buffer.","summary":"<p>Creates a deep copy of this NArray; Allocates a new buffer of the same shape, and calls #clone on every item in the buffer.</p>","abstract":false,"args":[],"args_string":" : NArray(T)","source_link":null,"def":{"name":"clone","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"NArray(T)","visibility":"Public","body":"NArray(T).new(@shape, @buffer.clone)"}},{"id":"dimensions:Int32-instance-method","html_id":"dimensions:Int32-instance-method","name":"dimensions","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Int32","source_link":null,"def":{"name":"dimensions","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Int32","visibility":"Public","body":"@shape.size"}},{"id":"dup:NArray(T)-instance-method","html_id":"dup:NArray(T)-instance-method","name":"dup","doc":"Creates a shallow copy of this NArray;\nAllocates a new buffer of the same shape, and duplicates every item in the buffer.","summary":"<p>Creates a shallow copy of this NArray; Allocates a new buffer of the same shape, and duplicates every item in the buffer.</p>","abstract":false,"args":[],"args_string":" : NArray(T)","source_link":null,"def":{"name":"dup","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"NArray(T)","visibility":"Public","body":"NArray(T).new(@shape, @buffer.dup)"}},{"id":"each(&block:T->)-instance-method","html_id":"each(&block:T->)-instance-method","name":"each","doc":"Must yield this collection's elements to the block.","summary":"<p>Must yield this collection's elements to the block.</p>","abstract":false,"args":[],"args_string":"(&block : T -> )","source_link":null,"def":{"name":"each","args":[],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T -> )"},"return_type":"","visibility":"Public","body":"each_with_index do |elem|\n  yield elem\nend"}},{"id":"each_with_index(&block:T,Int32->)-instance-method","html_id":"each_with_index(&block:T,Int32->)-instance-method","name":"each_with_index","doc":"Iterates over the collection, yielding both the elements and their index.\n\n```\n[\"Alice\", \"Bob\"].each_with_index do |user, i|\n  puts \"User ##{i}: #{user}\"\nend\n```\n\nPrints:\n\n```text\nUser # 0: Alice\nUser # 1: Bob\n```\n\nAccepts an optional *offset* parameter, which tells it to start counting\nfrom there. So, a more human friendly version of the previous snippet would be:\n\n```\n[\"Alice\", \"Bob\"].each_with_index(1) do |user, i|\n  puts \"User ##{i}: #{user}\"\nend\n```\n\nWhich would print:\n\n```text\nUser # 1: Alice\nUser # 2: Bob\n```","summary":"<p>Iterates over the collection, yielding both the elements and their index.</p>","abstract":false,"args":[],"args_string":"(&block : T, Int32 -> )","source_link":null,"def":{"name":"each_with_index","args":[],"double_splat":null,"splat_index":null,"yields":2,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T, Int32 -> )"},"return_type":"","visibility":"Public","body":"@buffer.each_with_index do |elem, idx|\n  yield elem, idx\nend"}},{"id":"each_with_indices(&block:T,Array(Int32),Int32->)-instance-method","html_id":"each_with_indices(&block:T,Array(Int32),Int32->)-instance-method","name":"each_with_indices","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"(&block : T, Array(Int32), Int32 -> )","source_link":null,"def":{"name":"each_with_indices","args":[],"double_splat":null,"splat_index":null,"yields":3,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T, Array(Int32), Int32 -> )"},"return_type":"","visibility":"Public","body":"each_with_index do |elem, idx|\n  yield elem, unpack_index(idx), idx\nend"}},{"id":"extract_buffer_indices(coord):Tuple(Array(Int32),Array(Int32))-instance-method","html_id":"extract_buffer_indices(coord):Tuple(Array(Int32),Array(Int32))-instance-method","name":"extract_buffer_indices","doc":"maps an n-dimensional\nto a list of buffer indices that","summary":"<p>maps an n-dimensional to a list of buffer indices that</p>","abstract":false,"args":[{"name":"coord","doc":null,"default_value":"","external_name":"coord","restriction":""}],"args_string":"(coord) : Tuple(Array(Int32), Array(Int32))","source_link":null,"def":{"name":"extract_buffer_indices","args":[{"name":"coord","doc":null,"default_value":"","external_name":"coord","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Tuple(Array(Int32), Array(Int32))","visibility":"Public","body":"shape = [] of Int32\nchunk_start_indices = [0]\ncoord.each_with_index do |rule, axis|\n  step = (@shape[(axis + 1)..]? || [1]).product\n  new_indices = [] of Int32\n  case rule\n  when Range\n    range, dir = canonicalize_range(rule, axis)\n    chunk_start_indices.each do |ref|\n      range.step(dir) do |index|\n        new_indices << (ref + ((index * step) * 1))\n      end\n    end\n    shape << rule.size\n  when Int32\n    index = canonicalize_index(rule, axis)\n    if index < 0 || index >= @shape[axis]\n      raise(IndexError.new(\"Could not canonicalize index: #{rule} is not a sensible index in axis #{index}.\"))\n    end\n    chunk_start_indices.each do |ref|\n      new_indices << (ref + (index * step))\n    end\n    shape << 1\n  else\n    puts(\"Not a Range or Integer!\")\n  end\n  chunk_start_indices = new_indices\nend\n{shape, chunk_start_indices}\n"}},{"id":"flatten:NArray(T)-instance-method","html_id":"flatten:NArray(T)-instance-method","name":"flatten","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : NArray(T)","source_link":null,"def":{"name":"flatten","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"NArray(T)","visibility":"Public","body":"NArray.new([@shape.product], @buffer.dup)"}},{"id":"get(*coord):T-instance-method","html_id":"get(*coord):T-instance-method","name":"get","doc":"Given a fully-qualified coordinate, returns the scalar at that position.","summary":"<p>Given a fully-qualified coordinate, returns the scalar at that position.</p>","abstract":false,"args":[{"name":"coord","doc":null,"default_value":"","external_name":"coord","restriction":""}],"args_string":"(*coord) : T","source_link":null,"def":{"name":"get","args":[{"name":"coord","doc":null,"default_value":"","external_name":"coord","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"T","visibility":"Public","body":"@buffer[pack_index(coord)]"}},{"id":"get_buffer_idx(index):T-instance-method","html_id":"get_buffer_idx(index):T-instance-method","name":"get_buffer_idx","doc":null,"summary":null,"abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index) : T","source_link":null,"def":{"name":"get_buffer_idx","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"T","visibility":"Public","body":"@buffer[index]"}},{"id":"map(&block:T->U)forallU-instance-method","html_id":"map(&block:T->U)forallU-instance-method","name":"map","doc":"Returns an `Array` with the results of running the block against each element of the collection.\n\n```\n[1, 2, 3].map { |i| i * 10 } # => [10, 20, 30]\n```","summary":"<p>Returns an <code>Array</code> with the results of running the block against each element of the collection.</p>","abstract":false,"args":[],"args_string":"(&block : T -> U) forall U","source_link":null,"def":{"name":"map","args":[],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T -> U)"},"return_type":"","visibility":"Public","body":"map_with_index do |elem|\n  yield elem\nend"}},{"id":"map!(&block:T->U)forallU-instance-method","html_id":"map!(&block:T->U)forallU-instance-method","name":"map!","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"(&block : T -> U) forall U","source_link":null,"def":{"name":"map!","args":[],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T -> U)"},"return_type":"","visibility":"Public","body":"map_with_index! do |elem|\n  yield elem\nend"}},{"id":"map_with_index(&block:T,Int32->U)forallU-instance-method","html_id":"map_with_index(&block:T,Int32->U)forallU-instance-method","name":"map_with_index","doc":"Like `map`, but the block gets passed both the element and its index.\n\n```\n[\"Alice\", \"Bob\"].map_with_index { |name, i| \"User ##{i}: #{name}\" }\n# => [\"User #0: Alice\", \"User #1: Bob\"]\n```\n\nAccepts an optional *offset* parameter, which tells it to start counting\nfrom there.","summary":"<p>Like <code><a href=\"../Lattice/NArray.html#map(&block:T-%3EU)forallU-instance-method\">#map</a></code>, but the block gets passed both the element and its index.</p>","abstract":false,"args":[],"args_string":"(&block : T, Int32 -> U) forall U","source_link":null,"def":{"name":"map_with_index","args":[],"double_splat":null,"splat_index":null,"yields":2,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T, Int32 -> U)"},"return_type":"","visibility":"Public","body":"buffer = Slice(U).new(@shape.product) do |idx|\n  yield @buffer[idx], idx\nend\nNArray(U).new(@shape, buffer)\n"}},{"id":"map_with_index!(&block:T,Int32->T)forallT-instance-method","html_id":"map_with_index!(&block:T,Int32->T)forallT-instance-method","name":"map_with_index!","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"(&block : T, Int32 -> T) forall T","source_link":null,"def":{"name":"map_with_index!","args":[],"double_splat":null,"splat_index":null,"yields":2,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T, Int32 -> T)"},"return_type":"","visibility":"Public","body":"@buffer.map_with_index! do |elem, idx|\n  yield elem, idx\nend\nself\n"}},{"id":"map_with_indices(&block:T,Array(Int32),Int32->U)forallU-instance-method","html_id":"map_with_indices(&block:T,Array(Int32),Int32->U)forallU-instance-method","name":"map_with_indices","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"(&block : T, Array(Int32), Int32 -> U) forall U","source_link":null,"def":{"name":"map_with_indices","args":[],"double_splat":null,"splat_index":null,"yields":3,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T, Array(Int32), Int32 -> U)"},"return_type":"","visibility":"Public","body":"map_with_index do |elem, idx|\n  yield elem, unpack_index(idx), idx\nend"}},{"id":"map_with_indices!(&block:T,Array(Int32),Int32->U)forallU-instance-method","html_id":"map_with_indices!(&block:T,Array(Int32),Int32->U)forallU-instance-method","name":"map_with_indices!","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"(&block : T, Array(Int32), Int32 -> U) forall U","source_link":null,"def":{"name":"map_with_indices!","args":[],"double_splat":null,"splat_index":null,"yields":3,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(T, Array(Int32), Int32 -> U)"},"return_type":"","visibility":"Public","body":"map_with_index! do |elem, idx|\n  yield elem, unpack_index(idx), idx\nend"}},{"id":"pack_index(indices):Int32-instance-method","html_id":"pack_index(indices):Int32-instance-method","name":"pack_index","doc":"Convert from n-dimensional indexing to a buffer location.","summary":"<p>Convert from n-dimensional indexing to a buffer location.</p>","abstract":false,"args":[{"name":"indices","doc":null,"default_value":"","external_name":"indices","restriction":""}],"args_string":"(indices) : Int32","source_link":null,"def":{"name":"pack_index","args":[{"name":"indices","doc":null,"default_value":"","external_name":"indices","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Int32","visibility":"Public","body":"NArray.pack_index(indices, @shape)"}},{"id":"reshape(new_shape)-instance-method","html_id":"reshape(new_shape)-instance-method","name":"reshape","doc":null,"summary":null,"abstract":false,"args":[{"name":"new_shape","doc":null,"default_value":"","external_name":"new_shape","restriction":""}],"args_string":"(new_shape)","source_link":null,"def":{"name":"reshape","args":[{"name":"new_shape","doc":null,"default_value":"","external_name":"new_shape","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"NArray(T).new(new_shape, @buffer)"}},{"id":"scalar?-instance-method","html_id":"scalar?-instance-method","name":"scalar?","doc":"Checks that the array is a 1-vector (a \"zero-dimensional\" NArray)","summary":"<p>Checks that the array is a 1-vector (a \"zero-dimensional\" NArray)</p>","abstract":false,"args":[],"args_string":"","source_link":null,"def":{"name":"scalar?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(@shape.size == 1) && (@shape[0] == 1)"}},{"id":"set(coord,value:T)-instance-method","html_id":"set(coord,value:T)-instance-method","name":"set","doc":"replaces all values in an indexed chunk with the given value.","summary":"<p>replaces all values in an indexed chunk with the given value.</p>","abstract":false,"args":[{"name":"coord","doc":null,"default_value":"","external_name":"coord","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"T"}],"args_string":"(coord, value : T)","source_link":null,"def":{"name":"set","args":[{"name":"coord","doc":null,"default_value":"","external_name":"coord","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"T"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"shape, mapping = extract_buffer_indices(coord)\nmapping.each do |index|\n  @buffer[index] = value\nend\n"}},{"id":"set(coord,value:NArray(T))-instance-method","html_id":"set(coord,value:NArray(T))-instance-method","name":"set","doc":"replaces an indexed chunk with a given chunk of the same shape.","summary":"<p>replaces an indexed chunk with a given chunk of the same shape.</p>","abstract":false,"args":[{"name":"coord","doc":null,"default_value":"","external_name":"coord","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"NArray(T)"}],"args_string":"(coord, value : NArray(T))","source_link":null,"def":{"name":"set","args":[{"name":"coord","doc":null,"default_value":"","external_name":"coord","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"NArray(T)"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"shape, mapping = extract_buffer_indices(coord)\nif value.shape != shape\n  raise(DimensionError.new(\"Cannot substitute array: given array does not match shape of specified slice.\"))\nend\nmapping.each_with_index do |dst_idx, src_idx|\n  @buffer[dst_idx] = value.buffer[src_idx]\nend\n"}},{"id":"shape:Array(Int32)-instance-method","html_id":"shape:Array(Int32)-instance-method","name":"shape","doc":"Returns an array where `shape[i]` is the size of the NArray in the `i`th dimension.","summary":"<p>Returns an array where <code>shape[i]</code> is the size of the NArray in the <code>i</code>th dimension.</p>","abstract":false,"args":[],"args_string":" : Array(Int32)","source_link":null,"def":{"name":"shape","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Array(Int32)","visibility":"Public","body":"@shape.clone"}},{"id":"to_a:Array(T)-instance-method","html_id":"to_a:Array(T)-instance-method","name":"to_a","doc":"Returns an `Array` with all the elements in the collection.\n\n```\n(1..5).to_a # => [1, 2, 3, 4, 5]\n```","summary":"<p>Returns an <code>Array</code> with all the elements in the collection.</p>","abstract":false,"args":[],"args_string":" : Array(T)","source_link":null,"def":{"name":"to_a","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Array(T)","visibility":"Public","body":"@buffer.to_a"}},{"id":"to_s:String-instance-method","html_id":"to_s:String-instance-method","name":"to_s","doc":"Returns a string representation of this object.\n\nDescendants must usually **not** override this method. Instead,\nthey must override `to_s(io)`, which must append to the given\nIO object.","summary":"<p>Returns a string representation of this object.</p>","abstract":false,"args":[],"args_string":" : String","source_link":null,"def":{"name":"to_s","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"String","visibility":"Public","body":"NArrayFormatter.format(self)"}},{"id":"to_s(io:IO)-instance-method","html_id":"to_s(io:IO)-instance-method","name":"to_s","doc":"Override for printing a string output to stream (e.g., puts)","summary":"<p>Override for printing a string output to stream (e.g., puts)</p>","abstract":false,"args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":"IO"}],"args_string":"(io : IO)","source_link":null,"def":{"name":"to_s","args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":"IO"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"NArrayFormatter.print(self, io)"}},{"id":"to_scalar:T-instance-method","html_id":"to_scalar:T-instance-method","name":"to_scalar","doc":"Maps a zero-dimensional NArray to the element it contains.","summary":"<p>Maps a zero-dimensional NArray to the element it contains.</p>","abstract":false,"args":[],"args_string":" : T","source_link":null,"def":{"name":"to_scalar","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"T","visibility":"Public","body":"if scalar?\n  return @buffer[0]\nelse\n  raise(DimensionError.new(\"Cannot cast to scalar: NArray has more than one dimension or more than one element.\"))\nend"}},{"id":"to_tensor:Tensor(T)-instance-method","html_id":"to_tensor:Tensor(T)-instance-method","name":"to_tensor","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Tensor(T)","source_link":null,"def":{"name":"to_tensor","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Tensor(T)","visibility":"Public","body":"Tensor.new(self)"}},{"id":"unpack_index(index):Array(Int32)-instance-method","html_id":"unpack_index(index):Array(Int32)-instance-method","name":"unpack_index","doc":"Convert from a buffer location to an n-dimensional indexing","summary":"<p>Convert from a buffer location to an n-dimensional indexing</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index) : Array(Int32)","source_link":null,"def":{"name":"unpack_index","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Array(Int32)","visibility":"Public","body":"NArray.unpack_index(index, @shape)"}},{"id":"valid_index?(indices)-instance-method","html_id":"valid_index?(indices)-instance-method","name":"valid_index?","doc":"Checks if a given list of integers represent an index that is in range for this `NArray`.","summary":"<p>Checks if a given list of integers represent an index that is in range for this <code><a href=\"../Lattice/NArray.html\">NArray</a></code>.</p>","abstract":false,"args":[{"name":"indices","doc":null,"default_value":"","external_name":"indices","restriction":""}],"args_string":"(indices)","source_link":null,"def":{"name":"valid_index?","args":[{"name":"indices","doc":null,"default_value":"","external_name":"indices","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"NArray.valid_index?(indices, @shape)"}}],"macros":[{"id":"method_missing(call)-macro","html_id":"method_missing(call)-macro","name":"method_missing","doc":null,"summary":null,"abstract":false,"args":[{"name":"call","doc":null,"default_value":"","external_name":"call","restriction":""}],"args_string":"(call)","source_link":null,"def":{"name":"method_missing","args":[{"name":"call","doc":null,"default_value":"","external_name":"call","restriction":""}],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      def \n{{ call.name.id }}\n(*args : *U) forall U\n          \n\\{% for\n i in 0...(U.size) %}\n            \n\\{% if\n U[i] < NArray %}\n              if args[\n\\{\n{i}}].shape != @shape\n                raise DimensionError.new(\"Could not apply .\n{{ call.name.id }}\n elementwise - Shape of argument does match dimension of `self`\")\n              \nend\n            \n\\{% end\n %}\n          \n\\{% end\n %}\n\n          new_buffer = @buffer.map_with_index do |elem, buf_idx|\n            \n\\{% \nbegin %}\n              \n# Note: Be careful with this section. Adding newlines can break this code because it might put commas on their\n\n              \n# own lines.\n\n              \nelem.\n{{ call.name.id }}\n(\n                \n\\{% for\n i in 0...(U.size) %}\\\n                  \n\\{% if\n U[i] < NArray %} args[\n\\{\n{i}}].buffer[buf_idx] \n\\{% e\nlse %} args[\n\\{\n{i}}] \n\\{% end\n %} \n\\{% if\n i < U.size - 1 %}, \n\\{% end\n %}\n                \n\\{% end\n %}\\\n              )\n            \n\\{% end\n %}\n          \nend\n          \n          NArray.new(shape, new_buffer)\n      \nend\n    \n"}}],"types":[]},{"html_id":"lattice/Lattice/NArrayFormatter","path":"Lattice/NArrayFormatter.html","kind":"module","full_name":"Lattice::NArrayFormatter","name":"NArrayFormatter","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"lattice","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[{"html_id":"lattice/Lattice/NArrayFormatter","kind":"module","full_name":"Lattice::NArrayFormatter","name":"NArrayFormatter"}],"subclasses":[],"including_types":[],"namespace":{"html_id":"lattice/Lattice","kind":"module","full_name":"Lattice","name":"Lattice"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[{"id":"format(narr):String-instance-method","html_id":"format(narr):String-instance-method","name":"format","doc":null,"summary":null,"abstract":false,"args":[{"name":"narr","doc":null,"default_value":"","external_name":"narr","restriction":""}],"args_string":"(narr) : String","source_link":null,"def":{"name":"format","args":[{"name":"narr","doc":null,"default_value":"","external_name":"narr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"String","visibility":"Public","body":"builder = String::Builder.new\nprint(narr, io: builder)\nbuilder.to_s\n"}},{"id":"print(narr,io=STDOUT)-instance-method","html_id":"print(narr,io=STDOUT)-instance-method","name":"print","doc":null,"summary":null,"abstract":false,"args":[{"name":"narr","doc":null,"default_value":"","external_name":"narr","restriction":""},{"name":"io","doc":null,"default_value":"STDOUT","external_name":"io","restriction":""}],"args_string":"(narr, io = <span class=\"t\">STDOUT</span>)","source_link":null,"def":{"name":"print","args":[{"name":"narr","doc":null,"default_value":"","external_name":"narr","restriction":""},{"name":"io","doc":null,"default_value":"STDOUT","external_name":"io","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"print_internal(narr, io, start_dim: 0, buffer_idx: [0], shape: narr.shape)"}}],"macros":[],"types":[]}]}]}})